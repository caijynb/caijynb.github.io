修饰符用于确定solidity 函数可见性

常用的可见性修饰符有：

## internal

这样声明的函数为内部函数，只能在合约内部访问，在当前合约内或继承的合约里调用。

函数调用时只能f()，不能加前缀this，前缀this表示通过外部方式访问。

在不指定任何修饰符的情况下，internal就是默认的修饰符



## external

外部函数，合约接口的一部分，通过其他合约或交易来发起调用。外部函数只能this.f()的方式被调用，不能通过f()的方式内部调用。



## public

公开函数，合约接口的一部分。内部、外部调用都可以。public类型的状态变量，会自动创建一个范根器。



## private

私有函数，以及用private修饰的状态变量，仅在当前合约中可以访问，在继承的合约中也不可访问。



## constant

constant修饰的函数没有能力改变区块链上的状态变量，这样函数的执行就不再消耗gas了，因为不再需要矿工去验证。他们可以读取状态变量并返回给调用者。但函数本身并不能改变变量、调用时间、调用可能改变状态的函数、创建另一个合约。

constant修饰符会被包含在函数的json abi文件里，而且会被官方的web3.js所使用。它可以被用来判断函数是通过交易还是call调用。



## view

等同于constant



## pure

类似constant，但是pure函数不能读写状态变量



## payable

payable声明的函数可以从调用者那里接受ether





## 修饰符的细节

### （1）internal调用永远消耗燃料最少

因为它是通过jump指令来实现的，参数是以内存指针来传递。



### （2）constant函数调用不消耗燃料

constant修饰的函数没有能力改变区块链上的状态变量，这样函数的执行就不再消耗gas了，因为不再需要矿工去验证。



### （3）external和public的区别

从可见上来说，external和public基本一样，都支持外部调用。当一个合约被部署到链上，external和public函数都可以被其他合约调用或者通过交易调用。

但是public函数不知道调用者是external或者internal，所以会把参数复制到mermory,操作非常昂贵。

此外public内部调用和外部调用都支持，external函数只支持外部调用。因此确信一个函数只能被外部调用，使用external修饰符

大部分情况下，this.f()调用方式没有意义，因为他会引起一个昂贵的call指令



### 





