{"./":{"url":"./","title":"前言","keywords":"","body":"介绍 Golang是由google开发的一款静态强类型，编译型语言。 应用 Go语言在区块链开发和恶意软件编写上的应用比较多。 刚好我是一名在区块链公司实习的信息安全专业学生，感觉可太有必要学go了 安装 go的安装，主要是在ubuntu上用apt-get install的版本太低了 go1.16.5.1只是目前的最新版，大家可以根据官网的给出的最新版地址去下载安装 wget -c https://golang.org/dl/go1.16.5.linux-amd64.tar.gz -O - | sudo tar -xz -C /usr/local vim /etc/profile export PATH=$PATH:/usr/local/go/bin #写入到/etc/profile首行 source /etc/profile "},"variable.html":{"url":"variable.html","title":"常量与变量声明","keywords":"","body":"常量 声明常量的关键字是const func main() { const year = 21 const name = \"cjy\" fmt.Printf(\"My name is %v,I'm %v years old\", name, year) } 声明常量没什么可说的，在go中唯一值得注意的一点就是：常量被声明后，可以不像变量一样一定要使用，但是不能被重新赋值，会引起编译器报错。 变量 变量声明 go声明变量的关键字是var。以下3种都是go的变量声明方式： var age_1 uint8 = 31 var age_2 = 32 age_3 := 33 可见go变量声明还是比较灵活的，可以带变量类型（不过和别的语言不一样的是，Go是变量名在前变量类型在后），也可以像python一样，不带变量类型，声明变量的同时赋值，编译器会根据变量的值自动推导变量类型。 声明变量带变量类型，但不赋值，有一个zero value。 此外，最后一种方式叫变量短命名。变量短命名可以让for循环的循环索引在循环开始的时候临时定义使用，保证它的作用域只在for循环中。 同时声明多个变量： var 变量名1, 变量名2 var 变量名1, 变量名2 = 值1, 值2 变量名1, 变量名2 := 值1, 值2 // 方法1:括号包裹，变量赋值直接换行 var ( distance=100 speed=50 ) 变量类型 变量类型 说明 bool 布尔类型，值为true或false。go中的1和0不代表true或false int、uint int、uint类型会根据计算机的硬件选择最合适的位长（32位或64位）。声明整型变量时,类型推断默认使用int。 Int8、uint8 -128到127、0到255（2^8-1） int16、uint16 -32768到32767、0到65535 int32、uint32 -2147483648到2147483647、0到4294967295 int64、uint64 -9223372036854775808到9223372036854775807、0到18446744073709551615 float64 64位，占用8个字节。声明浮点类型变量时,类型推断默认使用float64 float32 32位，占用4个字节 string 字符串类型，GO会把双引号包裹起来的字面值推断成string类型。 [] 定义数组 数组 声明 func main() { var names [5]string //声明一个定长数组 names[0] = \"test\" fmt.Println(names[1]) //打印数组中未被赋值的元素并不会报错 var ages = []int{32, 55, 32} //声明一个不定长数组并赋值 fmt.Println(ages[1]) //55 } 声明定长数组并赋值，不一定要给所有元素都赋值 数字数组为声明的元素值一律为0 用变量短命名的方式声明数组，必须同时给它赋值 数组是值类型 这和大部分语言（如python）数组（列表）是引用类型不一样 最明显的表现是当数组作为参数传入函数的时候，别的语言都是引用传递，函数中对数组的改变直接生效。 Go则不同，是值传递，拷贝了一个新的数组参与函数的运算。作为参数的那个数组变量变量 def changeFirst(arr): arr[0]=100 print(arr) if __name__ == \"__main__\": arr1 = [88, 11, 32, 11, 67] changeFirst(arr1) print(arr1) \"\"\" [100, 11, 32, 11, 67] [100, 11, 32, 11, 67] \"\"\" func changeFirst(arr [5]int){ arr[0]=100 fmt.Println(arr) } func main() { var arr1 = [5]int{88,11,32,11,67} changeFirst(arr1) fmt.Println(arr1) } /* [100 11 32 11 67] [88 11 32 11 67] */ 想让Go函数数组做参数引用传递也很简单，函数定义时参数类型前面加个*，函数使用传参时数组变量前面加个&取地址 func changeFirst(arr *[5]int){ arr[0]=100 fmt.Println(arr) } func main() { var arr1 = [5]int{88,11,32,11,67} changeFirst(&arr1) fmt.Println(arr1) } /* &[100 11 32 11 67] [100 11 32 11 67] */ 切片 go语言一般不直接使用数组，而是使用切片（slice），切片是指向数组的视图。 PS：声明数组的时候，[]int这种不定长数组，也是一种切片。 func main() { var arr = [6]int{88,11,32,11,67,55} fmt.Println(\"arr[2:6] = \",arr[2:6]) fmt.Println(\"arr[2:] = \",arr[2:]) fmt.Println(\"arr[:6] = \",arr[:6]) fmt.Println(\"arr[:] = \",arr[:]) } /* arr[2:6] = [32 11 67 55] arr[2:] = [32 11 67 55] arr[:6] = [88 11 32 11 67 55] arr[:] = [88 11 32 11 67 55] */ 函数参数类型写成[]int就是切片，切片传参，是一种引用传递的方式，函数中对切片的修改会生效到原数组上 func changeSliceFirst(s []int){ s[0]=100 fmt.Println(s) } func main() { var arr = [6]int{88,11,32,11,67,55} changeSliceFirst(arr[:]) fmt.Println(arr) } /* [100 11 32 11 67 55] [100 11 32 11 67 55] */ append函数 不想python，append是数组的方法。go中append是一个内置的函数，它的参数1是要操作的切片，参数2可以是（一个或多个）元素，也可以是另一个切片...，...相当于遍历这个切片的所有元素。 看到这里我们就明白了，利用append函数可以实现添加元素和删除元素 func main() { var arr = []int{88,11,32,22,67,55} arr=append(arr, 123) fmt.Println(arr) arr=append(arr[:3],arr[4:]...) fmt.Println(arr) } /* [88 11 32 22 67 55 123] [88 11 32 67 55 123] */ map 就是别的语言的字典，但是go中map的value要求是同一类型 map [] func main() { m := map[string] string{ \"p1\":\"aaa\", \"p2\":\"bbb\", \"p3\":\"ccc\", \"p4\":\"ddd\", } for k,v := range m{ fmt.Printf(\"%v 是 %v\\n\",k,v) } } /* p4 是 ddd p1 是 aaa p2 是 bbb p3 是 ccc */ 发现遍历map并不是按顺序遍历的，而且每一次结果都不一样。这是因为map是无序的，hash map func main() { m := map[string] string{ \"p1\":\"aaa\", \"p2\":\"bbb\", \"p3\":\"ccc\", \"p4\":\"ddd\", } p1value := m[\"p1\"] fmt.Println(p1value) // aaa } 当我们去取map里不存在的key时，依然是可以取成功的，不会有报错，只不过返回零值。 那么如何判断值存不存在呢？ func main() { m := map[string] string{ \"p1\":\"aaa\", \"p2\":\"bbb\", \"p3\":\"ccc\", \"p4\":\"ddd\", } p1value,ok := m[\"p4\"] fmt.Println(p1value,ok) p2value,ok := m[\"p5\"] fmt.Println(p2value,ok) } /* ddd true false */ map增加或删除kv对 func main() { m := map[string] string{ \"p1\":\"aaa\", \"p2\":\"bbb\", \"p3\":\"ccc\", \"p4\":\"ddd\", } delete(m,\"p4\") fmt.Println(m) m[\"p5\"] = \"eee\" fmt.Println(m) } /* map[p1:aaa p2:bbb p3:ccc] map[p1:aaa p2:bbb p3:ccc p5:eee] */ 结构体 go里面是没有类的，所以结构体除了像别的语言可以实现自定义的数据结构，还相当于别的语言的类。 go语言面向对象只支持封装，不支持继承和多态。 结构体的创建 func main() { var root treeNode fmt.Println(root) //{0 } root = treeNode{value:3} root.left = &treeNode{} root.right = &treeNode{5,nil,nil} root.right.left = new(treeNode) fmt.Println(root) fmt.Println(root.right) fmt.Println(&root.right) fmt.Println(*root.right) } 结构体还可以通过工厂函数创建 func createNode(value int) *treeNode { return &treeNode{value: value} } 返回局部变量的地址，换别的语言就报错了，但是go没问题 方法 结构体的方法定义func (接收器名 结构体名) (){} 接收器名相当于其他语言的this type treeNode struct { value int left,right *treeNode } func createNode(value int) *treeNode { return &treeNode{value: value} } func (node treeNode) print(){ fmt.Println(node.value) } func (node treeNode) setValue(value int){ node.value = value } func main() { var root treeNode root = treeNode{value:3} root.left = &treeNode{} root.right = &treeNode{5,nil,nil} root.right.left = new(treeNode) root.left.right = createNode(8) root.left.right.setValue(5) root.left.right.print() //8 } 依然是8，并不是我们想要的5。这是因为go里面所有的函数参数都是值传递，函数中对参数的修改并不应用到传参的那个变量上来。 我们只要在定义函数的时候将参数类型前面加*，就可以改成引用传递（要改变内容必须使用值接受者） func (node *treeNode) setValue(value int){ node.value = value } 这样节点setValue(5)再print()结果就是5。go给参数类型加了*来引用传递参数，函数中使用参数直接照常使用，不需要使用*或->来。 "},"judge.html":{"url":"judge.html","title":"条件判断","keywords":"","body":"使用if进行分支判断 func main() { var today = \"monday\" if today == \"monday\"{ fmt.Println(\"fuck\") } else if today == \"friday\" { fmt.Println(\"nice\") } else { fmt.Println(\"boring\") } } if 条件{ ​ 语句 } 不需要像python一样加: 使用switch进行分支判断 switch 变量{ case : ​ 语句1 case : ​ 语句2 } func main() { var today = \"tuesday\" switch today { case \"monday\": //case 目标值: fmt.Println(\"fuck\") case \"friday\": fmt.Println(\"nice\") case \"tuesday\", \"wednesday\", \"thursday\": //使用,分割多个可选值 fmt.Println(\"boring\") } } switch的另一种用法是像if...else if...一样，在每个分支中单独设置比较条件 func main() { var today = \"tuesday\" switch { case today == \"monday\": //case 目标值: fmt.Println(\"fuck\") case today == \"tuesday\": fmt.Println(\"boring\") case today == \"friday\": fmt.Println(\"nice\") } } 此外，go语言switch还有独特的fallthrough关键字，用于执行下一个分支的代码 func main() { var today = \"tuesday\" switch { case today == \"monday\": //case 目标值: fmt.Println(\"fuck\") case today == \"tuesday\": fmt.Println(\"boring\") fallthrough case today == \"friday\": fmt.Println(\"nice\") } } 之前是只单单打印一个boring，现在会连着打印boring和nice "},"function.html":{"url":"function.html","title":"函数","keywords":"","body":"go定义函数的关键字是func 函数声明方式： func 函数名( ) { 代码 } 其中参数名和返回值类型都是可选的 匿名函数 var f = func (){ fmt.Println(\"hello,world\")} func main(){ f() } var f = func (x string){ fmt.Println(x)} func main(){ f(\"hello,world\") } "},"loop.html":{"url":"loop.html","title":"循环","keywords":"","body":"for循环 func main() { var count = 10 for count > 0 { fmt.Println(count) time.Sleep(time.Second) count-- } } 当然这样比较不优雅，变量的设置;变量的比较;变量的自增自减都可以写在for后面 func main() { var arr1 = [5]int{88,11,32,11,67} for i:=0;i 有意思的是，Go是没有while关键字的，是通过不为for语句设置任何条件来产生无限循环的，然后在有需要的时候通过在循环体内部使用break语句跳出循环 func main() { var degrees = 0 for { fmt.Println(degrees) degrees++ if degrees >= 10 { degrees = 0 if rand.Intn(2) == 0 { break } } } } 遍历数组 go的for循环非常棒，默认的遍历和python的enumerate一样，返回索引和元素。但是我们这里不需要索引值，就用_占位。 func main(){ namearr := [] string{\"zhangsan\",\"lisi\",\"wangwu\"} for i,name := range namearr{ fmt.Printf(\"第%v人是：%v \\n\",i+1,name) } } func main(){ namearr := [] string{\"zhangsan\",\"lisi\",\"wangwu\"} for _,name := range namearr{ fmt.Println(name) } } "},"package.html":{"url":"package.html","title":"包","keywords":"","body":"包 每个目录只能有一个包（目录名和包名可以不同，约定上一般目录名和包名保持一致。一个包可以由多个go文件组成，所以显然包名和go文件名可以不同） main包包含可执行入口，即main函数必须写在main包里面 go因为没有继承，所以只有public和private两种访问属性，不需要额外声明。包名、结构名、结构内变量名，结构方法名首字母大写表示对别的包可见（public），首字母小写表示对别的包不可见（private） tree/node.go package tree import \"fmt\" type TreeNode struct { Value int Left,Right *TreeNode } func (node TreeNode) Print(){ fmt.Println(node.Value) } func (node *TreeNode) SetValue(value int){ node.Value = value } tree/entry/entry.go package main import \"studygo/tree\" func main() { var root tree.TreeNode root.SetValue(5) root.Print() } 拓展已有类型 因为go里面的包不支持继承，那么我们能不能在别的包使用这个包给它的结构新增一些方法呢？ 当然是可以的，我们只需要新定义一个结构，这个结构只定义一个属性变量，类型是原来的结构（注意用引用传递），就可以写这个结构的方法。 tree/entry/entry.go package main import ( \"fmt\" \"studygo/tree\" ) type myTreeNode struct { node *tree.TreeNode } func (mynode myTreeNode) isEven() { if mynode.node.Value % 2 == 0{ //mynode.node mynode是没有node属性的 fmt.Println(\"yes\") } } func main() { var root tree.TreeNode root.SetValue(8) root.Print() myTreeNode{&root}.isEven() } 但是这样子写还是有点麻烦，可以使用内嵌的方式省略属性变量的定义。新定义的struct直接引用传递原来的struct，不需要写属性变量。拓展的方法也不需要再指向某个属性。 package main import ( \"fmt\" \"studygo/tree\" ) type myTreeNode struct { *tree.TreeNode } func (mynode myTreeNode) isEven() { if mynode.Value % 2 == 0{ fmt.Println(\"yes\") } } func main() { var root tree.TreeNode root.SetValue(8) root.Print() myTreeNode{&root}.isEven() } "},"go mod.html":{"url":"go mod.html","title":"go module","keywords":"","body":"go的依赖管理，经历了GOPATH、GOVENDOR，但是这些都是靠修改路径实现的，比较繁琐。直到18年时GO 1.11推出了go mod，这才是比较成熟的依赖管理方式。 GOPATH 新建一个目录，export GOPATH=这个目录。 再目录下新建一个src目录，把包放src下 vendor 每个项目下新建一个vendor目录，把包放vendor目录下 解决不同项目使用不同版本的同一个包的冲突问题 go module new project -> go modules （这是ide的快捷操作，我们也可以自行在project目录下使用go mod init命令初始化go.mod文件） 项目会有一个go.mod go get -u go.uber.org/zap go get 安装依赖，-u 表示把如果之前安装过，更新最新版安装。 go module下载下来的包在GOROOT/pkg/mod里： 如何添加新的包呢？继续使用go get。 原来是可以直接代码中import，go run的时候会自动解析下载包。但go 1.16版本后，运行go命令（go run, go build,go test）时，如果import的依赖在go.mod文件中没有，不会再自动下载并修改go.mod和go.sum文件，而会提示需要手动执行 go get命令下载对应的包。原因是如果导入的包在没有提供任何依赖的情况自动添加新依赖，则可能会引起公共依赖包的升级等。 如果我们更新了项目的依赖，go.mod、go.sum文件可能会多一些文件。可以使用go mod tidy清理多余没有用的依赖 "},"interface.html":{"url":"interface.html","title":"接口","keywords":"","body":""}}