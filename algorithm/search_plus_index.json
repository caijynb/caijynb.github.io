{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"sort.html":{"url":"sort.html","title":"排序算法","keywords":"","body":" 冒泡排序 冒泡排序是最简单基础的算法，就是遍历元素，每次遍历元素时将它逐个和后面的元素比大小，按比较结果决定是否交换顺序。所有元素遍历完，得到的数组就是有序的。 因为每次都是把较小（大）的元素移到后面，所以非常形象的像桶装水的气泡向上冒，因而被称为冒泡排序。 实际上标准的冒泡排序时间复杂度始终为o(n^2)。有序情况下时间复杂度是o(n)，是改进了冒泡排序的算法，设置了一个标志位。 def bubbleSort(arr): n =len(arr) for i in range(n-1): for j in range(i+1,n): if arr[i] > arr[j]: arr[i],arr[j] = arr[j],arr[i] return arr 选择排序 选择排序在思路上也很简单，就是依次从未排序的数组中找出最小（大）的成员，放到已排序数组的末尾。 升序排列（从小到大）就设minIndex def selectSort(arr): n = len(arr) for i in range(n - 1): minIndex = i for j in range(i + 1, n): if arr[j] > arr[minIndex]: minIndex = j # 当i对应的数不是最小数时，将其互换 if i != minIndex: arr[i], arr[minIndex] = arr[minIndex], arr[i] return arr 快速排序 快排应该是最有名的一种排序方式，思路其实也还成，但是实现上要比冒泡排序和选择排序难很多。对应的快排自然也会快很多，虽然在最极端情况下它的时间复杂度也是接近于o(n^2) 快排到思路是从数列里挑出一个元素，设为基准（pivot），然后将比它小的元素移到它左边，将比它大的元素移到它右边，这个叫分区操作。分区结束后这个元素就处于数列的中间位置。递归操作左分区和右分区。 为了操作简单，我们一般是选左端点作为基准值的。但是这样容易出现极端情况(如果本身就是升序数组的话，这样的时间复杂度拉满)，所以可以选一个随机值。让其与左端点互换。 def quickSort(arr, start, end): # 只剩一个元素时，不用再进行排序 if start >= end: return arr pivot = arr[start] l, r = start, end rdx = random.randint(start, end) nums[start], nums[rdx] = nums[rdx], nums[start] while l = pivot: r -= 1 # 循环直到左边比基准值大的成员结束。 while l "},"search.html":{"url":"search.html","title":"查找算法","keywords":"","body":"顺序查找 没什么好说的，就是遍历整个数组。因为我们刷题用的程序语言是python，用enumerate定位到某个元素的同时可以直接返回它的索引 二分查找 二分查找是一种在有序数组（嗯，前面学的排序算法不就派上用场了）中找一特定元素的算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 def search(nums, target): left, right = 0, len(nums) - 1 # 左端点和右端点比较，一定是 "},"DP.html":{"url":"DP.html","title":"动态规划","keywords":"","body":"动态规划思想 动态规划（Dynamic Programming）是一种算法思想：若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划一般适用于找寻问题的最优解。 动态规划方法 Leetcode 斐波那契数 题目描述 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你 n ，请计算 F(n) 。 示例 1： 输入：2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2： 输入：3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3： 输入：4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： 0 题解 递归 递归的思路就是：F(n) = F(n-1) + F(n-2) 边界条件是n2开始递归 class Solution: def fib(self, n: int) -> int: if n 递归+记忆化搜索 递归分为两段，当n=2 f(n)=f(n-1)+f(n-2)。因此我们可以写出递归函数 记忆化搜索可以称缓存，利用@lru_cache()装饰递归函数实现。本质上是一种动态规划 class Solution: def fib(self, n: int) -> int: @lru_cache() def f(n): if n 动态规划 本质递归思路，只不过用数组记录下来所有小于n的fib(n) class Solution: def fib(self, n: int) -> int: data = [0, 1] for i in range(n-1): data.append(data[-2] + data[-1]) return data[n] "},"linkedlist.html":{"url":"linkedlist.html","title":"链表","keywords":"","body":"链表结构 链表是基础常考的一种数据结构 链表是一种线性表，但不是线性的顺序存储，而是在每一个节点里存当前节点的值，和下一个节点的位置指针 class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next PS: 链表是一个抽象的数据结构，或者说严格来说并没有一个链表的数据类型。一般我们都是定义节点(ListNode)类型，通过头节点，从而在逻辑上形成了整个链表。 链表方法 遍历链表 while L: L.val L = L.next Leetcode 两数相加 题目描述 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0] 输出：[0] 示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内 0 题解 很简单的思路，就是把链表转数字，数字相加转回链表。这样就不需要考虑进位的问题，也不需要考虑链表长度不一的问题。 留意toll这个函数把数字转成链表，返回的只是头节点。所以我们需要两个变量，一个变量保存头节点，一个变量用于遍历，让节点不断向下。 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next def tonum(L): result = 0 i = 0 while L: result += L.val * 10**i i += 1 L = L.next return result def toll(n): num = n - n//10 *10 temp = cur = ListNode(num) n = n // 10 while n: (n,s) = divmod(n,10) cur.next = ListNode(s) cur = cur.next return temp class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode: n1 = tonum(l1) n2 = tonum(l2) n = n1 + n2 return toll(n) 反转链表 题目描述 给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。 示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2： 输入：head = [1,2] 输出：[2,1] 示例 3： 输入：head = [] 输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 题解 class Solution: def reverseList(self, head: ListNode) -> ListNode: if not head: return head arr = [] while head: arr.append(head.val) head = head.next i = len(arr)-1 newhead = cur = ListNode(arr[i]) i -= 1 while i >= 0 : cur.next = ListNode(arr[i]) cur = cur.next i -= 1 return newhead 和两数相加比较像的思路，先转数组，再数组转链表。这里一开始犯傻了，没有设两个变量且循环只有cur.next = ListNode(arr[i])，head=[1 2 3 4 5] ，返回的结果是[5 1]。加了cur = cur.next，返回的结果是[1] 所以必须设置两个变量，一个变量用于保存头节点，一个变量用于遍历 "}}