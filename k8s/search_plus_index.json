{"./":{"url":"./","title":"前言","keywords":"","body":"k8s的意义 要学习k8s，首先我们要理解k8s出现的作用或者说意义，这里需要从应用部署变迁的发展看。 传统部署：物理服务器上运行应用程序，物理服务器无法很好的控制资源边界，会导致资源分配出现问题，应用程序性能下降 虚拟化部署：虚拟化技术允许在单个物理服务器上运行多个虚拟机（vm）,每个vm都是一台完整的计算机，有自己的操作系统。 容器部署：具有自己的文件系统、CPU、内存、进程空间等。类似vm，但是更轻量。与vm的区别在于容器的操作系统内核是共享的，容器上运行的应用进程与操作系统分离。大名鼎鼎的docker是容器应用的代表。 容器部署应用的优势非常明显，启动速度快，资源利用效率高，占用空间小。是现在以及未来的发展方向 K8s就应运而生，是编排管理容器的应用。负责管理容器在哪个机器上运行，监控容器是否存在问题，控制容器和外界的通信等等。这些功能专业的术语叫服务发现、负载均衡、存储编排、自动部署...保证了我们对外提供的服务是利用容器部署的，有分流有灾备的自动切换，大大提供了应用部署的稳定性。 "},"concept.html":{"url":"concept.html","title":"概念","keywords":"","body":"namespace 命名空间（namespace），用于在多个用户之间划分集群资源。形成逻辑上分组的不同项目、用户组。 node node、节点，即独立的一台服务器，每个节点会被master分配一些工作负载，当节点宕机时，它的工作负载会被master自动转移到其他节点上。 master master是集群控制管理的节点，k8s集群都必须有一个mastrt来负责整个集群的管理和控制，所有的kubernetes控制命令都是发给master，由它来负责具体的执行 pod pod是运行在节点上的一组（一个或多个）容器。这些容器共享存储、网络、以及怎样运行这些容器的声明。 deployment 怎样运行这些容器的声明，就是deployment了。deployment用于在节点上编排pod，通过创建deployment来完成对pod的创建。 statefulset statefulset同deployment 一样，是pod的管理对象。区别在于deployment管理的pod，一般都是无状态的服务。但是一些服务是有状态的，特别是一些复杂的中间件，比如mysql、MongoDB、zookeeper、reddis。 有状态的服务集群要求部署的节点有固定的身份id，这样便于集群成员去发现这个服务。此外需要对数据做持久化存储 通过deployment控制pod副本，pod的名称是随机的、ip地址也是运行期才分配的。 因此引入了statefulset这个资源对象。statefulset里的pod都有固定、唯一的网络标示，可以用来发现集群内的其他成员。statefulset里的pod采用稳定的持久化存储卷，通过PV或PVC来实现，删除POD时默认不会删除与stateful相关的存储卷 Volume 存储卷，是Pod中能够被多个容器访问的共享目录。Kubernetes的Volume概念、用途和目的与Docker的Volume比较类似，但两者不能等价。 首先，Kubernetes中的Volume被定义在Pod上，然后被一个Pod里的多个容器挂载到具体的文件目录下；其次，Kubernetes中的Volume与Pod的生命周期相同，但与容器的生命周期不相关，容器终止或者重启时，Volume中的数据也不会丢失。 Persistent Volume Volume是被定义在Pod上的，属于计算资源的一部分。 Persistent Volume是网络存储，是相对独立于计算资源而存在的一种实体资源。 PV可以被理解成Kubernetes集群中的某个网络存储对应的一块存储。不属于任何的Node，不被Pod定义，但每个Node和Pod都可以访问。 ConfigMap ConifgMap这个概念需要从docker说起 Docker通过将程序、依赖库、数据及配置文件“打包固化”到一个不变的镜像文件中的做法，解决了应用的部署的难题，但这同样带来了问题：即配置文件中的参数在运行期如何修改的问题。docker提供了两种常见的解决方案： 在运行时通过容器的环境变量来传递参数 通过Docker Volume将容器外的配置文件映射到容器内 在分布式系统运行的情况下，这两种方式都不合适。因为在多台服务器上修改其上运行的多个服务的配置文件实在是太麻烦了... ConfigMap提供了集中管理系统的配置参数的作用，所有的配置项都是键值对字符串。这些配置项可以作为Map表中的一个项，整个Map的数据可以被持久化存储在k8s的Etcd数据库中，然后提供API以方便k8s相关组件或客户应用CRUD操作这些数据。k8s还提供了一种内建机制，将存储在etcd中的ConfigMap通过Volume映射的方式变成目标Pod内的配置文件。如果ConfigMap中的key-value数据被修改，则映射到Pod中的“配置文件”也会随之自动更新。 "},"network.html":{"url":"network.html","title":"k8s网络","keywords":"","body":"service service 微服务架构中的服务 每个Pod都会被分配一个单独的IP地址，可以通过endpoint(端点，IP地址+容器端口)以被客户端访问。但是多个Pod副本组成一个集群来提供服务时，就需要部署负载均衡器，为这组Pod开启一个对外的服务端口如8000端口，并且将这些Pod的Endpoint列表加入8000端口的转发列表，客户端就可以通过负载均衡的对外IP地址+服务端口来访问此服务。客户端的请求最后会被转发到哪个Pod，由负载均衡的算法所决定。 k8s中每个node上运行的kube-proxy进程就是用于实现负载均衡，而且k8s的另一个特点是：每个service会被分配一个全局唯一的虚拟的Cluster IP。每个服务就变成了具备唯一IP地址的通信节点，服务调用就变成了最基础的TCP网络通信问题。因此k8s集群内部的服务发现也变得非常简单，只要用Service的Name与Service的Cluster IP地址做一个DNS域名映射。 需要对外暴露的服务，配置NodePort，然后通过NodeIP:NodePort的方式访问 k8s中有三种IP： Node IP：Node的IP地址 Node IP是Kubernetes集群中每个节点的物理网卡的IP地址，是一个真实存在的物理网络，所有属于这个网络的服务器都能通过这个网络直接通信，不管其中是否有部分节点不属于这个Kubernetes集群。Kubernetes集群之外的节点访问Kubernetes集群之内的某个节点或者TCP/IP服务时，都必须通过NodeIP通信。 Pod IP：Pod的IP地址 Pod IP是每个Pod的IP地址，它是Docker Engine根据docker0网桥的IP地址段进行分配的，通常是一个虚拟的二层网络，前面说过，Kubernetes要求位于不同Node上的Pod都能够彼此直接通信，所以Kubernetes里一个Pod里的容器访问另外一个Pod里的容器时，就是通过Pod IP所在的虚拟二层网络进行通信的，而真实的TCP/IP流量是通过Node IP所在的物理网卡流出的。 Cluster IP：Service的IP地址 Cluster IP仅仅作用于Kubernetes Service这个对象，但并没有一个实体网络对象支持。所以只能k8s集群内部访问，无法与外部通信。 ingress Service的表现形式为IP:Port，即工作在TCP/IP层。而对于基于HTTP的服务来说，不同的URL地址经常对应到不同的后端服务器。这些应用层的转发机制仅通过Kubernetes的Service机制是无法实现的。 因此kubernetes新增Ingress资源对象，用于将不同URL的访问请求转发到后端不同的Service。 Kubernetes使用了一个Ingress策略定义和一个具体的Ingress Controller，两者结合并实现了一个完整的Ingress负载均衡器。使用Ingress进行负载分发时，Ingress Controller基于Ingress规则将客户端请求直接转发到Service对应的后端Endpoint（Pod）上，这样会跳过kube-proxy的转发功能，kube-proxy不再起作用。 看到这里，瞬间心想这不就是nginx的反向代理吗？区别只是k8s的ingress是将请求转发到k8s的service，而nginx则是将请求转发给服务器。 事实上，k8s中ingress的实现也是基于nginx的。 "},"kubectl.html":{"url":"kubectl.html","title":"kubecrl","keywords":"","body":"Kubectl是kubernetes的命令行工具，可以直接快速创建、更新Kubernetes对象。 kubectl的语法是： kubectl [command] [TYPE] [NAME] [flags] command：指定要对一个或多个资源执行的操作，例如 create、get、describe、delete。 TYPE：指定资源类型。资源类型不区分大小写， 可以指定单数、复数或缩写形式。例如，以下命令输出相同的结果: kubectl get pod pod1 kubectl get pods pod1 kubectl get po pod1 NAME：指定资源的名称。名称区分大小写。 如果省略名称，则显示所有资源的详细信息 kubectl get pods。 flags: 指定可选的参数。例如，可以使用 -s 或 -server 参数指定 Kubernetes API 服务器的地址和端口。 我们可以从增删改查四个方面去学习kubectl的用法。 因为我是在公司的业务基础上学习的，所以我从kubectl的查询开始学起 查 get get命令用于基本输出 kubectl get namespace kubectl get nodes kubectl get pods kubectl get service 搭配-o wide参数可以显示更详细信息 主要查询对象是pods和service，一般会跟--namespace=来指定所在的namespace，当指定资源名称后，可以跟-o yaml获取pod和service配置的yaml文件。 describe get命令查询到的内容比较简单，一般都是用get查有哪些对象后用describe来查看具体的内容的 改 kubectl edit service "}}