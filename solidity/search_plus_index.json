{"./":{"url":"./","title":"Introduction","keywords":"","body":"介绍 Solidity是是一款基于以太坊虚拟机 Ethereum Virtual Machine (EVM)的智能合约编写语言。是一种静态语言，支持继承、库、复杂类型定义等功能。 Solidity开发环境配置 一般来说solidity开发用的ide都是web端的remix，直接翻墙用官网 此外就是给浏览器安装个metamask钱包插件。 以下都是在服务器上配置的： nodejs安装 apt-get install curl -y curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash - apt-get install -y nodejs 如此就安装好了nodejs和npm setup_14.x中的14可根据当前nodejs LTS版本更换成别的 Go安装 wget -c https://golang.org/dl/go1.16.5.linux-amd64.tar.gz -O - | sudo tar -xz -C /usr/local vim /etc/profile export PATH=$PATH:/usr/local/go/bin #写入到/etc/profile首行 source /etc/profile git安装 apt-get install git -y 以太坊源码（geth）编译 mkdir geth cd geth git init git remote add origin https://github.com/ethereum/go-ethereum git pull origin master apt-get install make make geth 编译好之后会有Run \"./build/bin/geth\" to launch geth.的说明 web3.js包 web3库是使用最广泛的以太坊开发程序包，我们通过npm来安装 npm install web3 -g ganache安装 ganache用于创建测试账号和私钥，其实我感觉装不装都没啥问题 npm install -g ganache-cli truffle安装 Truffle是一个优秀的开发环境，测试框架、以太坊的资源管理通道。 npm install -g truffle mkdir test && cd test truffle init tree . ├── contracts │ └── Migrations.sol ├── migrations │ └── 1_initial_migration.js ├── test └── truffle-config.js contracts solidity合约目录 migrations 可编程部署脚本文件 test 用来测试App和合约的测试文件目录 truffle-config.js truffle配置文件 solc命令行编译器 npm install -g solc npm install -g solc-cli sol文件结构 1.编译开关 paragma solidity ^0.4.0 编译开关，表明需要编译器高于0.4.0版本才可以编译,^表示如果编译器版本低于0.4.0则不可编译，也可以指定编译器的版本范围 paragma solidity >=0.4.22 2.引入其他源文件 全局引入 import \"\" 自定义命名空间引入 import * as \"\" 3.注释 // 单行注释 /* 这是 多行注释 */ "},"contract.html":{"url":"contract.html","title":"合约","keywords":"","body":"solidity中最重要的对象就是contract，比较像面向对象编程语言里面的类。 "},"variable.html":{"url":"variable.html","title":"常量与变量声明","keywords":"","body":"变量声明 solidity的变量声明非常简单 = // 声明同时赋值 solidity的变量把写在函数外的变量叫状态变量，永久地储存在合约里。 变量类型 值类型 变量类型 说明 bool 值为true或false，solidity中1、0不能代表true、false int/uint 整型，int和uint默认都是256。还有int8、int16、int24、int32...int256和uint8、uint16、uint24、uint32...uint256 address 地址类型，长度为20B，以太坊地址是由私钥算出公钥，取公钥后40位作为地址。前面会加0x,所以整个地址字符串有42个字符。 byte 定长字节数字，有byte1，byte2，byte3...byte32。可以设定16进制或数字的字面量，也可以设定字符 enum 枚举类型是solidity中的一种用户自定义类型 contract test{ // 枚举类型demo enum Direction{east,south,west,north} Direction choice; } 引用类型 变量类型 说明 bytes 不定长字节数组是个动态数组，能够容纳任意长度的字节。 string 字符串 int[]或uint[] 数组，创建时需要利用new关键字。默认是可以通过.length修改长度的storage数字，但是也有定长的memory数组 struct 结构体，组合数据类型 contract test{ function f(){ uint[]memory a = new uint[](7); } uint[] b; function g(){ b = new uint[](7); b.length = 10; b[9] = 100; } } contract test{ struct people{ address addr; string name; } } 数据位置 合约里声明的每一个变量都有一个数据位置，一般是默认的。 但是在solidity 5.0以后的版本，引用类型（bytes、string、int[]、struct）的参数/变量/返回值在声明的时候必须要显式的添加”data location”的声明（专门写在后面）。 四种data location: storage ：永久的存储，写入区块链中（局部变量、状态变量默认是storage） memory：在合约中的本地内存变量，生命周期很短，函数执行结束后就销毁。不会被写入区块链中持久化 (函数的入参出参都用memory) calldata：所有函数的调用数据，包括函数参数的保存位置。不可修改，但是不会被写入区块链中持久化（external 函数的入参是强制的calldata类型） stack：以太坊的栈，1024级深，超过就会抛出异常。一般我们在声明引用类型数据位置时不会使用stack storge永久保存合约的状态变量，消耗燃料最多。memory仅保存临时变量，函数调用之后释放，消耗燃料很小。calldata包含消息体的数据，其计算需要n(非零字节数)*68的gas费用。stack仅保存很小的局部变量，免费使用，但有数量限制（16个变量）"},"operator.html":{"url":"operator.html","title":"运算符","keywords":"","body":"运算符没什么好说的，所有语言基本一样，大同小异。 solidity里逻辑运算符 &&和| 三元操作 ? : "},"modifier.html":{"url":"modifier.html","title":"修饰符","keywords":"","body":"修饰符用于确定solidity 函数可见性 常用的可见性修饰符有： internal 这样声明的函数为内部函数，只能在合约内部访问，在当前合约内或继承的合约里调用。 函数调用时只能f()，不能加前缀this，前缀this表示通过外部方式访问。 在不指定任何修饰符的情况下，internal就是默认的修饰符 external 外部函数，合约接口的一部分，通过其他合约或交易来发起调用。外部函数只能this.f()的方式被调用，不能通过f()的方式内部调用。 public 公开函数，合约接口的一部分。内部、外部调用都可以。public类型的状态变量，会自动创建一个范根器。 private 私有函数，以及用private修饰的状态变量，仅在当前合约中可以访问，在继承的合约中也不可访问。 constant constant修饰的函数没有能力改变区块链上的状态变量，这样函数的执行就不再消耗gas了，因为不再需要矿工去验证。他们可以读取状态变量并返回给调用者。但函数本身并不能改变变量、调用时间、调用可能改变状态的函数、创建另一个合约。 constant修饰符会被包含在函数的json abi文件里，而且会被官方的web3.js所使用。它可以被用来判断函数是通过交易还是call调用。 view 等同于constant pure 类似constant，但是pure函数不能读写状态变量 payable payable声明的函数可以从调用者那里接受ether 修饰符的细节 （1）internal调用永远消耗燃料最少 因为它是通过jump指令来实现的，参数是以内存指针来传递。 （2）constant函数调用不消耗燃料 constant修饰的函数没有能力改变区块链上的状态变量，这样函数的执行就不再消耗gas了，因为不再需要矿工去验证。 （3）external和public的区别 从可见上来说，external和public基本一样，都支持外部调用。当一个合约被部署到链上，external和public函数都可以被其他合约调用或者通过交易调用。 但是public函数不知道调用者是external或者internal，所以会把参数复制到mermory,操作非常昂贵。 此外public内部调用和外部调用都支持，external函数只支持外部调用。因此确信一个函数只能被外部调用，使用external修饰符 大部分情况下，this.f()调用方式没有意义，因为他会引起一个昂贵的call指令 "},"loop.html":{"url":"loop.html","title":"循环","keywords":"","body":"for循环 for (i ; i } while循环 while (insertIndex>0 && bid.limit solidity的while循环里也有break和continue方法 "},"function.html":{"url":"function.html","title":"函数","keywords":"","body":"solidity是门静态类型语言，对数据类型要求比较严格。solidity里面函数在定义时，如果有参数，必须以 参数名的方式声明。如果函数有返回值，必须以returns ()的方式一并声明。 function hello() constant returns (string){ return \"hello\"; } "},"event.html":{"url":"event.html","title":"事件","keywords":"","body":""}}